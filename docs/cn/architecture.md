# 架构概述

JournalQ是一个兼容多协议的分布式发布/订阅消息中间件，由协议、生产、消费、存储引擎、高可用、命名服务等模块组成。

一般来说，主题包含多个分区组，分区组又包含多个分区。同一分区组的所有分区都分布在同一个消息中间件实例上，同一主题的所有分区组可以分布在不同的消息中间件实例上，这有利于主题的水平扩展。不同消息中间件实例上的同一个分区组将构成集群，只有主分区组可以处理生产和消费请求。

JournalQ 的主要模块如下图所示：

![JournalQ highlight](../img/journalQ-arch-cluster.png "JournalQ architecture")

## 集群

JournalQ的核心模块如消息的存储、生产和消费。此外，还有一些功能是生产环境所必需的模块，如归档、重试、高可用（选举和复制）及监控等。

重试模块用于丢弃或者暂时跳过部分消息，随后再去消费它。例如，消费者无法识别非预期的消息格式，将导致消费卡住，在这中情况下，可以很容易丢弃或者暂时跳过这条消息。JounalQ单个实例的存储通常受限于磁盘的大小，归档模块采用某种清理策略将已经消费的消息存储到更大的存储系统，如HDFS，这一个功能确保用户可以查看几个月以前生产的消息。监控模块管理着实时的监控数据，如积压、重试、入队、出队以及连接数，这些直观的数据有助于管理人员了解运行情况。高可用模块由选举和复制组成，它管理跟随者并向它们复制消息，一旦主节点挂掉，这些跟随者会选出新的主，继续对外提供服务，目前JournalQ采用的是raft选举算法。

## 命名服务

命名服务主要用于服务发现和提供元数据，所有的实例都包含一个采用嵌入式Ignite实现的命名服务。

## 生产者

同一个生产者可能同时向多个主题生产消息，同一个主题可能会有多个生产者向它发送消息，生产者可以采用默认或者自定义的负载均衡策略向集群发送消息。


## 消费者

同一个消费者可以消费多个主题的消息，同一主题可能有多个消费者。JournalQ支持组消费和广播消费两种模式，在组消费模式下，JournalQ会协调同一个主题的消费者去不同的分区消费，消费位置由JournalQ服务端保存；而在广播模式中，消费者的消费位置仅保存到本地。
